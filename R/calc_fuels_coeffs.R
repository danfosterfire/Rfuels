

# Get Species Codes ------------------------------------------------------------

#' Get species codes
#'
#' Internal function only, see 'estimate_fuel_loads.R' for call. We want a
#' list of all the species codes included
#' in the dataset (and including only those species actually
#' present in the dataset). The tidy dataset returned
#' by aggregate_treelist() (with a row for each
#' plot_id:inv_date and a column for the proportion of basal area for each
#' species) already includes the correct species codes. We want to scan the
#' column names to see the codes which were present in the dataset.
#'
#' @param dataset A tidy dataset with observation ID info and overstory data
#' (the proportion of basal area occupied by each species,
#' 'pBA_species'). 'dataset' is the result of calling aggregate_treelist() on
#' the observed treelist data.
#'
#' @return A vector listing the 4-letter codes for each species included in the
#' dataset, for feeding to the 'get_fuels_coefficients' functions.
#'
get_spp_codes = function(dataset){

    # the dataset already has a column for the proportion of plot basal area
    # occupied by each species, so start with the current list of columns
    result = names(dataset)

    # these are all the pre-set columns which give observation ID info or
    # fuels measurements (or the total plot basal area proportion)
    remove = c('plot_id', 'inv_date','pBA_(all)')

    # we want to drop all these, and just keep the 'pBA_[species]' col names
    result = result[! result %in% remove]

    # and subset the strings from 'pBA_[species]' to just '[species]'
    result = sapply(result, FUN = function(x){substring(x,5)}, USE.NAMES = FALSE)

    # finally, return the result
    return(result)
  }

# Lookup Van Wagtendonk Values -------------------------------------------------

#' Lookup Van Wagtendonk Values
#'
#' Internal only. Helper function to fetch a specific constant from the
#' tables reported by Van Wagtendonk et al. (1996) and (1998) based on the
#' type of constant (which table to check, e.g. QMD_cm or SEC), the species
#' (which row to check), and the specific value
#' (which column, e.g. 1-hour or 1-hour ).
#'
#'@param constants A dataframe with the relevant constants table. See
#' data-raw/build_constants_tables.R for construction of the dataframes.
#'
#'@param species String with the desired species code, drawn from the set of
#'codes included in the 'spp' columns included in the 'constants' dataframe.
#'
#'@param value String giving the desired value (column) from the table.
#'
#'
lookup_vw =
  function(constants, species, value){

    return(constants[constants$'spp'==species, value])

  }


# Litter and Duff Coefficients -------------------------------------------------

#' Calculate coefficients
#'
#' Van Wagtendonk et al. (1998) table 7 gives the fitted coefficients for a
#' linear relationship predicting measured fuelbed weight (kg / m^2) for
#' the litter and/or duff of 19 Sierra Nevada conifers as a function of
#' litter and/or duff depth (cm). Following Stephens et al. (2001), we
#' estimate the linear coefficient between litter/duff depth and litter/duff
#' fuelbed weight by taking the average of the coefficients for each
#' species present on the plot. The various coefficients  are weighted by the
#' proportion of total plot basal area occupied by each species. For more
#' details, see the vignette.
#'
#' @param dataset A tidy data table with a row for each observation (brown's
#' transect), and columns for the plot identifier ('plot_id'), the inventory
#' date ('inv_date'), the proportion of basal area occupied by each species
#' ('pBA_species'), the azimuth for the Brown's transect ('azimuth'),
#' tallies for 1-hour, 10-hour, and 100-hour fuels ('count_1h', 'count_10h',
#' 'count_100h'), transect-average litter and duff depths in centimeters
#' ('duff_depth_cm' and 'litter_depth_cm'), and the sum-of-squared-diameters
#' for the rotten and sound 1000-hour fuels on the transect ('sum_d2_1000r_cm2'
#' and 'sum_d2_1000s_cm2').
#'
#' @param species_list A characters vector giving the unique species codes
#' present in the dataset. Generated by calling get_spp_codes(dataset).
#'
#' @param fuel_type A string, either 'duff_coeff' or 'litter_coeff', identifying
#' the targeted average coefficient.
#'
#' @return A weighted-average coefficient to predict litter or duff weight from
#' litter or duff depth for each observation, based on the overstory present
#' for that observation.
get_litterduff_coeffs =

  function(dataset, species_list, fuel_type){

    # each vector of coefficients has length equal to the number of rows
    # in the combined measurements table (the number of distinct observations)
    nrows = length(dataset[,'plot_id'])

    # create an empty vector to store the weighted coefficients
    weighted_coeffs = numeric(nrows)

    # 'fuel_type' must be either 'litter' or 'duff', else fail with an error
    if ((fuel_type != 'litter_coeff') & (fuel_type != 'duff_coeff')) {
      error('"fuel_type" must be either "litter" or "duff"!')
    }

    # for each row in the combined measurements table
    for (i in 1:nrows){

      # the weighted aggregate coefficient starts at 0
      weighted_coeff = 0

      # for each tree species included in the dataset
      for (spp in species_list){

        # look up the proportion of plot_id:inv_date basal area occupied by spp
        pba = dataset[i, paste0('pBA_', spp)]

        # look up the coefficient given by Van Wagtendonk for litter of spp
        coeff_spp =
          lookup_vw(constants = litterduff_coeffs,
                    species = spp,
                    value = fuel_type)

        # the weighted contribution to the overall coefficient is the
        # proportion of basal area * the species coefficient
        current_spp_weighted = coeff_spp*pba

        # include the weighted contribution of spp to the overall coefficient
        weighted_coeff = weighted_coeff + current_spp_weighted

        # repeat for every spp in the species_list
      }

      # the weighted coefficient for row i is the overall coefficient calculated
      # from all species * basal areas:
      weighted_coeffs[i] = weighted_coeff

      # repeat for all rows
    }

    # return the resulting vector of weighted coefficients
    return(weighted_coeffs)
  }

# 1-, 10-, and 100-hour coefficients -------------------------------------------

#' 1-, 10-, and 100-hour coefficients
#'
#' Van Wagtendonk et al. (1996) tables 3, 6, and give the average quadratic
#' mean diamter, secant of acute angle, and specific gravity of woody
#' fuel particles of 21 Sierra Nevada conifers.
#' Following Stephens et al. (2001), we
#' estimate the average QMD, SEC, and SG by taking a weighted average of the
#' species-specific values. The various coefficients  are weighted by the
#' proportion of total plot basal area occupied by each species. For more
#' details, see the vignette.
#'
#' @param dataset A tidy data table with a row for each observation (brown's
#' transect), and columns for the plot identifier ('plot_id'), the inventory
#' date ('inv_date'), the proportion of basal area occupied by each species
#' ('pBA_species'), the azimuth for the Brown's transect ('azimuth'),
#' tallies for 1-hour, 10-hour, and 100-hour fuels ('count_1h', 'count_10h',
#' 'count_100h'), transect-average litter and duff depths in centimeters
#' ('duff_depth_cm' and 'litter_depth_cm'), and the sum-of-squared-diameters
#' for the rotten and sound 1000-hour fuels on the transect ('sum_d2_1000r_cm2'
#' and 'sum_d2_1000s_cm2').
#'
#' @param species_list A characters vector giving the unique species codes
#' present in the dataset. Generated by calling get_spp_codes(dataset).
#'
#' @param fuel_type A string, either 'duff_coeff' or 'litter_coeff', identifying
#' the targeted average coefficient.
#'
#' @return The function returns a vector of the product of
#' the weighted-average QMD, SEC, and SG for each observation in the dataset.
get_fwd_coeffs =

  function(dataset, species_list, timelag_class){

    # get the number of rows in the dataset
    nrows = length(dataset[,'plot_id'])

    # make an empty vector to store the coefficients
    weighted_coeffs = numeric(nrows)

    # timelag class must be one of 'x1h', 'x10h', or 'x100h'
    if (!is.element(timelag_class, c('x1h', 'x10h', 'x100h'))) {
      error('timelag_class must be one of "x1h", "x10h", or "x100h"!')
    }

    # for each row in the dataset
    for (i in 1:nrows){

      # the weighted aggregate values for qmd, SEC, and SG start at 0
      average_qmd = 0
      average_sec = 0
      average_sg = 0

      # for each tree species included in the dataset
      for (spp in species_list){

        # look up the proportion of plot_id:inv_date basal area occupied by spp
        pba = dataset[i, paste0('pBA_', spp)]

        # look up the average qmd, sec, and sg of 1h fuels from spp
        qmd_spp = lookup_vw(constants = QMDcm,
                           species = spp,
                           value = timelag_class)

        sec_spp = lookup_vw(constants = SEC,
                           species = spp,
                           value = timelag_class)

        sg_spp = lookup_vw(constants = SG,
                           species = spp,
                           value = timelag_class)

        # this species' weighted contribution to the average is the proportion
        # of basal area times the species' coefficient
        weighted_qmd = pba * qmd_spp
        weighted_sec = pba * sec_spp
        weighted_sg = pba * sg_spp

        # include the weighted contribution of spp in the overall coefficient
        average_qmd = average_qmd + weighted_qmd
        average_sec = average_sec + weighted_sec
        average_sg = average_sg + weighted_sg

        # repeat for every tree species in the dataset
      }

      # the weighted coefficient for row i is the product of the species-
      # weighted averages for QMD, SEC, and SG:
      weighted_coeffs[i] = average_qmd * average_sec * average_sg

      # repeat for every row in the dataset

    }

    # return the coefficients
    return(weighted_coeffs)

  }

# 1000-hour coefficients -------------------------------------------------------

#' 1000-hour coefficients
#'
#' do stuff
#'
#'
get_1000h_coeffs =

  function(dataset, species_list, type) {

    # get the total number of rows in the dataset
    nrows = length(dataset[,'plot_id'])

    # make an empty vector to store results
    weighted_coeffs = numeric(nrows)

    # type must be either 'rotten' or 'sound'
    if (!is.element(type, c('rotten', 'sound'))){
      error('type must be either "rotten" or "sound"!')
    }

    # if 'type' is 'sound:
    if (type == 'sound'){

      # for each row in the dataset
      for (i in 1:nrows){

        # the weighted aggregate values for SEC and SG start at 0
        average_sec = 0
        average_sg = 0

        # for each tree species in the dataset
        for (spp in species_list){

          # look up the proportion of plot_id:inv_date basal area occupied by spp
          pba = dataset[i, paste0('pBA_', spp)]

          # look up the species average values
          sec_spp = lookup_vw(constants = SEC,
                              species = spp,
                              value = 'x1000h')

          sg_spp = lookup_vw(constants = SG,
                             species = spp,
                             value = 'x1000s')

          # this species contribution to the weighted average is pBA*value_spp
          weighted_sec = pba * sec_spp
          weighted_sg = pba * sg_spp

          # update the runnign weighted averages
          average_sec = average_sec + weighted_sec
          average_sg = average_sg + weighted_sg

          # repeat for each species in the dataset
        }

        # the weighted coefficient for row i is the product of the species-
        # weighted averages of SEC and SG (we have observed QMD and dont need
        # to estimate it)
        weighted_coeffs[i] = average_sec * average_sg

        # repeat for every row in the dataset
      }
      # if the 'type' is 'rotten', we do something different:
    } else if (type == 'rotten'){

      # for each row in the dataset
      for (i in 1:nrows){

        # the weighted aggregate value for SEC starts at 0, SG for rotten
        # fuels does not vary by species:
        average_sec = 0
        average_sg = 0.36

        # for each tree species included in the dataset
        for (spp in species_list){

          # look up the proportion of plot_id:inv_date BA occupied by spp
          pba = dataset[i, paste0('pBA_', spp)]

          # get the species specific SEC value
          spp_sec = lookup_vw(constants = SEC,
                              species = spp,
                              value = 'x1000h')

          # weight this species' SEC by its pBA
          weighted_sec = pba * spp_sec

          # add the weighted average to the running total
          average_sec = average_sec + weighted_sec

          # repeat for all species in the dataset
        }

        # the weighted coefficient for row i is the product of the
        # species-weighted average for SEC and the (constant across species) SG
        weighted_coeffs[i] = average_sec * average_sg

        # repeat for every row in the dataset
      }

    }

    # return the weighted coefficients vector
    return(weighted_coeffs)

  }


